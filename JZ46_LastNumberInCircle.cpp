/*
    题目：
        0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。
        求出这个圆圈里剩下的最后一个数字。
        例如，0、1、2、3、4这5个数字组成一个圆圈，
        从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
    思路：
        模拟整个删除过程最直观，即构建一个长度为 nn 的链表，各节点值为对应的顺序索引；
                                每轮删除第 mm 个节点，直至链表长度为 1 时结束，返回最后剩余节点的值即可。
        但这样效率低，时间复杂度不可接受。
        实际上，本题是著名的 “约瑟夫环” 问题，可使用 动态规划 解决。
        m有可能大于n，所以要删除的数字是(m-1)%n;新一轮的删除从下个数字（即m%n）开始

*/

int LastRemaining_Solution(int n, int m){
    if(n == 0)
        return -1;
    int x = 0;
    for(int i = 2; i <= n; ++i)
        x = (x+m)%i;
    return x;
}